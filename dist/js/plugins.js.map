{"version":3,"names":[],"mappings":"","sources":["plugins.js"],"sourcesContent":["/*  ==|== Responsive =============================================================\n\tAuthor: James South\n\ttwitter : http://twitter.com/James_M_South\n\tgithub : https://github.com/ResponsiveBP/Responsive\n\tCopyright (c),  James South.\n\tLicensed under the MIT License.\n\t============================================================================== */\n\n/*! Responsive v2.5.7 | MIT License | responsivebp.com */\n\n/*\n * Responsive Core\n */\n\n/*global jQuery*/\n/*jshint forin:false, expr:true*/\n(function ($, w, d) {\n\n\t\"use strict\";\n\n\t$.support.transition = (function () {\n\t\t/// <summary>Returns a value indicating whether the browser supports CSS transitions.</summary>\n\t\t/// <returns type=\"Boolean\">True if the current browser supports css transitions.</returns>\n\n\t\tvar transitionEnd = function () {\n\t\t\t/// <summary>Gets transition end event for the current browser.</summary>\n\t\t\t/// <returns type=\"Object\">The transition end event for the current browser.</returns>\n\n\t\t\tvar div = d.createElement(\"div\"),\n\t\t\t\ttransEndEventNames = {\n\t\t\t\t\t\"transition\": \"transitionend\",\n\t\t\t\t\t\"WebkitTransition\": \"webkitTransitionEnd\",\n\t\t\t\t\t\"MozTransition\": \"transitionend\",\n\t\t\t\t\t\"OTransition\": \"oTransitionEnd otransitionend\"\n\t\t\t\t};\n\n\t\t\t// Could use the other method but I'm intentionally keeping them\n\t\t\t// separate for now.\n\t\t\tfor (var name in transEndEventNames) {\n\t\t\t\tif (div.style[name] !== undefined) {\n\t\t\t\t\treturn { end: transEndEventNames[name] };\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t};\n\n\t\treturn transitionEnd();\n\n\t}());\n\n\t$.fn.redraw = function () {\n\t\t/// <summary>Forces the browser to redraw by measuring the given target.</summary>\n\t\t/// <returns type=\"jQuery\">The jQuery object for chaining.</returns>\n\t\tvar redraw;\n\t\treturn this.each(function () {\n\t\t\tredraw = this.offsetWidth;\n\t\t});\n\t};\n\n\t$.fn.ensureTransitionEnd = function (duration) {\n\t\t/// <summary>\n\t\t/// Ensures that the transition end callback is triggered.\n\t\t/// http://blog.alexmaccaw.com/css-transitions\n\t\t///</summary>\n\t\tvar called = false,\n\t\t\t$this = $(this),\n\t\t\tcallback = function () { if (!called) { $this.trigger($.support.transition.end); } };\n\n\t\t$this.one($.support.transition.end, function () { called = true; });\n\t\tw.setTimeout(callback, duration);\n\t\treturn this;\n\t};\n\n\t$.fn.onTransitionEnd = function (callback) {\n\t\t/// <summary>Performs the given callback at the end of a css transition.</summary>\n\t\t/// <param name=\"callback\" type=\"Function\">The function to call on transition end.</param>\n\t\t/// <returns type=\"jQuery\">The jQuery object for chaining.</returns>\n\t\tvar supportTransition = $.support.transition;\n\n\t\treturn this.each(function () {\n\n\t\t\tif (!$.isFunction(callback)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar $this = $(this).redraw(),\n\t\t\t\trtransition = /\\d+(.\\d+)/;\n\n\t\t\tsupportTransition ? $this.one(supportTransition.end, callback)\n\t\t\t\t\t\t\t\t\t .ensureTransitionEnd((rtransition.test($this.css(\"transition-duration\")) ? $this.css(\"transition-duration\").match(rtransition)[0] : 0) * 1000)\n\t\t\t\t\t\t\t  : callback();\n\t\t});\n\t};\n\n\t$.support.touchEvents = (function () {\n\t\treturn (\"ontouchstart\" in w) || (w.DocumentTouch && d instanceof w.DocumentTouch);\n\t}());\n\n\t$.support.pointerEvents = (function () {\n\t\treturn (w.PointerEvent || w.MSPointerEvent);\n\t}());\n\n\t(function () {\n\t\tvar supportTouch = $.support.touchEvents,\n\t\t\tsupportPointer = $.support.pointerEvents;\n\n\t\tvar pointerStart = [\"pointerdown\", \"MSPointerDown\"],\n\t\t\tpointerMove = [\"pointermove\", \"MSPointerMove\"],\n\t\t\tpointerEnd = [\"pointerup\", \"pointerout\", \"pointercancel\", \"pointerleave\",\n\t\t\t\t\t\t  \"MSPointerUp\", \"MSPointerOut\", \"MSPointerCancel\", \"MSPointerLeave\"];\n\n\t\tvar touchStart = \"touchstart\",\n\t\t\ttouchMove = \"touchmove\",\n\t\t\ttouchEnd = [\"touchend\", \"touchleave\", \"touchcancel\"];\n\n\t\tvar mouseStart = \"mousedown\",\n\t\t\tmouseMove = \"mousemove\",\n\t\t\tmouseEnd = [\"mouseup\", \"mouseleave\"];\n\n\t\tvar getEvents = function (ns) {\n\t\t\tvar estart,\n\t\t\t\temove,\n\t\t\t\teend;\n\n\t\t\t// Keep the events separate since support could be crazy.\n\t\t\tif (supportTouch) {\n\t\t\t\testart = touchStart + ns;\n\t\t\t\temove = touchMove + ns;\n\t\t\t\teend = (touchEnd.join(ns + \" \")) + ns;\n\t\t\t}\n\t\t\telse if (supportPointer) {\n\t\t\t\testart = (pointerStart.join(ns + \" \")) + ns;\n\t\t\t\temove = (pointerMove.join(ns + \" \")) + ns;\n\t\t\t\teend = (pointerEnd.join(ns + \" \")) + ns;\n\n\t\t\t} else {\n\t\t\t\testart = mouseStart + ns;\n\t\t\t\temove = mouseMove + ns;\n\t\t\t\teend = (mouseEnd.join(ns + \" \")) + ns;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tstart: estart,\n\t\t\t\tmove: emove,\n\t\t\t\tend: eend\n\t\t\t};\n\t\t};\n\n\t\t$.fn.swipe = function (options) {\n\t\t\t/// <summary>Adds swiping functionality to the given element.</summary>\n\t\t\t/// <param name=\"options\" type=\"Object\" optional=\"true\" parameterArray=\"true\">\n\t\t\t///      A collection of optional settings to apply.\n\t\t\t///      &#10;    1: namespace - The namespace for isolating the touch events.\n\t\t\t/// </param>\n\t\t\t/// <returns type=\"jQuery\">The jQuery object for chaining.</returns>\n\n\t\t\tvar defaults = {\n\t\t\t\tnamespace: null,\n\t\t\t\ttouchAction: \"none\"\n\t\t\t},\n\t\t\t\tsettings = $.extend({}, defaults, options);\n\n\t\t\tvar ns = settings.namespace ? \".\" + settings.namespace : \"\",\n\t\t\t\teswipestart = \"swipestart\" + ns,\n\t\t\t\teswipemove = \"swipemove\" + ns,\n\t\t\t\teswipeend = \"swipeend\" + ns,\n\t\t\t\tetouch = getEvents(ns);\n\n\t\t\treturn this.each(function () {\n\t\t\t\tvar $this = $(this);\n\n\t\t\t\tif (supportPointer) {\n\t\t\t\t\t// Enable extended touch events on IE.\n\t\t\t\t\t$this.css({ \"-ms-touch-action\": \"\" + settings.touchAction + \"\", \"touch-action\": \"\" + settings.touchAction + \"\" });\n\t\t\t\t}\n\n\t\t\t\tvar start = {},\n\t\t\t\t\tdelta = {},\n\t\t\t\t\tisScrolling,\n\t\t\t\t\tonMove = function (event) {\n\n\t\t\t\t\t\t// Normalize the variables.\n\t\t\t\t\t\tvar isMouse = event.type === \"mousemove\",\n\t\t\t\t\t\t\tisPointer = event.type !== \"touchmove\" && !isMouse,\n\t\t\t\t\t\t\toriginal = event.originalEvent,\n\t\t\t\t\t\t\tmoveEvent;\n\n\t\t\t\t\t\t// Only left click allowed.\n\t\t\t\t\t\tif (isMouse && event.which !== 1) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// One touch allowed.\n\t\t\t\t\t\tif (original.touches && original.touches.length > 1) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Ensure swiping with one touch and not pinching.\n\t\t\t\t\t\tif (event.scale && event.scale !== 1) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar dx = (isMouse ? original.pageX : isPointer ? original.clientX : original.touches[0].pageX) - start.x,\n\t\t\t\t\t\t\tdy = (isMouse ? original.pageY : isPointer ? original.clientY : original.touches[0].pageY) - start.y;\n\n\t\t\t\t\t\t// Mimic touch action on iProducts.\n\t\t\t\t\t\t// Should also prevent bounce.\n\t\t\t\t\t\tif (!isPointer) {\n\t\t\t\t\t\t\tswitch (settings.touchAction) {\n\t\t\t\t\t\t\t\tcase \"pan-x\":\n\t\t\t\t\t\t\t\tcase \"pan-y\":\n\n\t\t\t\t\t\t\t\t\tisScrolling = settings.touchAction === \"pan-x\" ?\n\t\t\t\t\t\t\t\t\t\t\t\t  Math.abs(dy) < Math.abs(dx) :\n\t\t\t\t\t\t\t\t\t\t\t\t  Math.abs(dx) < Math.abs(dy);\n\n\t\t\t\t\t\t\t\t\tif (!isScrolling) {\n\t\t\t\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmoveEvent = $.Event(eswipemove, { delta: { x: dx, y: dy } });\n\n\t\t\t\t\t\t$this.trigger(moveEvent);\n\n\t\t\t\t\t\tif (moveEvent.isDefaultPrevented()) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Measure change in x and y.\n\t\t\t\t\t\tdelta = {\n\t\t\t\t\t\t\tx: dx,\n\t\t\t\t\t\t\ty: dy\n\t\t\t\t\t\t};\n\t\t\t\t\t},\n\t\t\t\t\tonEnd = function () {\n\n\t\t\t\t\t\t// Measure duration\n\t\t\t\t\t\tvar duration = +new Date() - start.time,\n\t\t\t\t\t\t\tendEvent;\n\n\t\t\t\t\t\t// Determine if slide attempt triggers slide.\n\t\t\t\t\t\tif (Math.abs(delta.x) > 1 || Math.abs(delta.y) > 1) {\n\n\t\t\t\t\t\t\t// Set the direction and return it.\n\t\t\t\t\t\t\tvar horizontal = delta.x < 0 ? \"left\" : \"right\",\n\t\t\t\t\t\t\t\tvertical = delta.y < 0 ? \"up\" : \"down\",\n\t\t\t\t\t\t\t\tdirection = Math.abs(delta.x) > Math.abs(delta.y) ? horizontal : vertical;\n\n\t\t\t\t\t\t\tendEvent = $.Event(eswipeend, { delta: delta, direction: direction, duration: duration });\n\n\t\t\t\t\t\t\t$this.trigger(endEvent);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Disable the touch events till next time.\n\t\t\t\t\t\t$this.off(etouch.move).off(etouch.end);\n\t\t\t\t\t};\n\n\t\t\t\t$this.off(etouch.start).on(etouch.start, function (event) {\n\n\t\t\t\t\t// Normalize the variables.\n\t\t\t\t\tvar isMouse = event.type === \"mousedown\",\n\t\t\t\t\t\tisPointer = event.type !== \"touchstart\" && !isMouse,\n\t\t\t\t\t\toriginal = event.originalEvent,\n\t\t\t\t\t\tstartEvent;\n\n\t\t\t\t\tif ((isPointer || isMouse) && $(event.target).is(\"img\")) {\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t}\n\n\t\t\t\t\t// Used for testing first move event\n\t\t\t\t\tisScrolling = undefined;\n\n\t\t\t\t\t// Measure start values.\n\t\t\t\t\tstart = {\n\t\t\t\t\t\t// Get initial touch coordinates.\n\t\t\t\t\t\tx: isMouse ? original.pageX : isPointer ? original.clientX : original.touches[0].pageX,\n\t\t\t\t\t\ty: isMouse ? original.pageY : isPointer ? original.clientY : original.touches[0].pageY,\n\n\t\t\t\t\t\t// Store time to determine touch duration.\n\t\t\t\t\t\ttime: +new Date()\n\t\t\t\t\t};\n\n\t\t\t\t\tstartEvent = $.Event(eswipestart, { start: start });\n\n\t\t\t\t\t$this.trigger(startEvent);\n\n\t\t\t\t\tif (startEvent.isDefaultPrevented()) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Reset delta and end measurements.\n\t\t\t\t\tdelta = { x: 0, y: 0 };\n\n\t\t\t\t\t// Attach touchmove and touchend listeners.\n\t\t\t\t\t$this.on(etouch.move, onMove)\n\t\t\t\t\t\t .on(etouch.end, onEnd);\n\t\t\t\t});\n\t\t\t});\n\t\t};\n\n\t\t$.fn.removeSwipe = function (namespace) {\n\t\t\t/// <summary>Removes swiping functionality from the given element.</summary>\n\t\t\t/// <param name=\"namespace\" type=\"String\">The namespace for isolating the touch events.</param>\n\t\t\t/// <returns type=\"jQuery\">The jQuery object for chaining.</returns>\n\n\t\t\tvar ns = namespace ? \".\" + namespace : \"\",\n\t\t\t\tetouch = getEvents(ns);\n\n\t\t\treturn this.each(function () {\n\n\t\t\t\t// Disable extended touch events on ie.\n\t\t\t\t// Unbind events.\n\t\t\t\t$(this).css({ \"-ms-touch-action\": \"\", \"touch-action\": \"\" })\n\t\t\t\t\t   .off(etouch.start).off(etouch.move).off(etouch.end);\n\t\t\t});\n\t\t};\n\n\t}());\n\n\t$.extend($.expr[\":\"], {\n\t\tattrStart: function (el, i, props) {\n\t\t\t/// <summary>Custom selector extension to allow attribute starts with selection.</summary>\n\t\t\t/// <param name=\"el\" type=\"DOM\">The element to test against.</param>\n\t\t\t/// <param name=\"i\" type=\"Number\">The index of the element in the stack.</param>\n\t\t\t/// <param name=\"props\" type=\"Object\">Metadata for the element.</param>\n\t\t\t/// <returns type=\"Boolean\">True if the element is a match; otherwise, false.</returns>\n\t\t\tvar hasAttribute = false;\n\n\t\t\t$.each(el.attributes, function () {\n\t\t\t\tif (this.name.indexOf(props[3]) === 0) {\n\t\t\t\t\thasAttribute = true;\n\t\t\t\t\treturn false;  // Exit the iteration.\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t});\n\n\t\t\treturn hasAttribute;\n\t\t}\n\t});\n\n\t$.buildDataOptions = function ($elem, options, prefix, namespace) {\n\t\t/// <summary>Creates an object containing options populated from an elements data attributes.</summary>\n\t\t/// <param name=\"$elem\" type=\"jQuery\">The object representing the DOM element.</param>\n\t\t/// <param name=\"options\" type=\"Object\">The object to extend</param>\n\t\t/// <param name=\"prefix\" type=\"String\">The prefix with which to identify the data attribute.</param>\n\t\t/// <param name=\"namespace\" type=\"String\">The namespace with which to segregate the data attribute.</param>\n\t\t/// <returns type=\"Object\">The extended object.</returns>\n\t\t$.each($elem.data(), function (key, val) {\n\n\t\t\tif (key.indexOf(prefix) === 0 && key.length > prefix.length) {\n\n\t\t\t\t// Build a key with the correct format.\n\t\t\t\tvar length = prefix.length,\n\t\t\t\t\tnewKey = key.charAt(length).toLowerCase() + key.substring(length + 1);\n\n\t\t\t\toptions[newKey] = val;\n\n\t\t\t\t// Clean up.\n\t\t\t\t$elem.removeData(key);\n\t\t\t}\n\n\t\t});\n\n\t\tif (namespace) {\n\t\t\t$elem.data(namespace + \".\" + prefix + \"Options\", options);\n\t\t} else {\n\t\t\t$elem.data(prefix + \"Options\", options);\n\t\t}\n\n\t\treturn options;\n\t};\n\n}(jQuery, window, document));\n\r/*! matchMedia() polyfill - Test a CSS media type/query in JS. Authors & copyright (c) 2012: Scott Jehl, Paul Irish, Nicholas Zakas, David Knight. Dual MIT/BSD license */\r\nwindow.matchMedia || (window.matchMedia = function() {\r\n\t\"use strict\";\r\n\r\n\t// For browsers that support matchMedium api such as IE 9 and webkit\r\n\tvar styleMedia = (window.styleMedia || window.media);\r\n\r\n\t// For those that don't support matchMedium\r\n\tif (!styleMedia) {\r\n\t\tvar style       = document.createElement('style'),\r\n\t\t\tscript      = document.getElementsByTagName('script')[0],\r\n\t\t\tinfo        = null;\r\n\r\n\t\tstyle.type  = 'text/css';\r\n\t\tstyle.id    = 'matchmediajs-test';\r\n\r\n\t\tscript.parentNode.insertBefore(style, script);\r\n\r\n\t\t// 'style.currentStyle' is used by IE <= 8 and 'window.getComputedStyle' for all other browsers\r\n\t\tinfo = ('getComputedStyle' in window) && window.getComputedStyle(style, null) || style.currentStyle;\r\n\r\n\t\tstyleMedia = {\r\n\t\t\tmatchMedium: function(media) {\r\n\t\t\t\tvar text = '@media ' + media + '{ #matchmediajs-test { width: 1px; } }';\r\n\r\n\t\t\t\t// 'style.styleSheet' is used by IE <= 8 and 'style.textContent' for all other browsers\r\n\t\t\t\tif (style.styleSheet) {\r\n\t\t\t\t\tstyle.styleSheet.cssText = text;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstyle.textContent = text;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Test if media query is true or false\r\n\t\t\t\treturn info.width === '1px';\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\r\n\treturn function(media) {\r\n\t\treturn {\r\n\t\t\tmatches: styleMedia.matchMedium(media || 'all'),\r\n\t\t\tmedia: media || 'all'\r\n\t\t};\r\n\t};\r\n}());\n\r/*! matchMedia() polyfill addListener/removeListener extension. Author & copyright (c) 2012: Scott Jehl. Dual MIT/BSD license */\r\n(function(){\r\n    // Bail out for browsers that have addListener support\r\n    if (window.matchMedia && window.matchMedia('all').addListener) {\r\n        return false;\r\n    }\r\n\r\n    var localMatchMedia = window.matchMedia,\r\n        hasMediaQueries = localMatchMedia('only all').matches,\r\n        isListening     = false,\r\n        timeoutID       = 0,    // setTimeout for debouncing 'handleChange'\r\n        queries         = [],   // Contains each 'mql' and associated 'listeners' if 'addListener' is used\r\n        handleChange    = function(evt) {\r\n            // Debounce\r\n            clearTimeout(timeoutID);\r\n\r\n            timeoutID = setTimeout(function() {\r\n                for (var i = 0, il = queries.length; i < il; i++) {\r\n                    var mql         = queries[i].mql,\r\n                        listeners   = queries[i].listeners || [],\r\n                        matches     = localMatchMedia(mql.media).matches;\r\n\r\n                    // Update mql.matches value and call listeners\r\n                    // Fire listeners only if transitioning to or from matched state\r\n                    if (matches !== mql.matches) {\r\n                        mql.matches = matches;\r\n\r\n                        for (var j = 0, jl = listeners.length; j < jl; j++) {\r\n                            listeners[j].call(window, mql);\r\n                        }\r\n                    }\r\n                }\r\n            }, 30);\r\n        };\r\n\r\n    window.matchMedia = function(media) {\r\n        var mql         = localMatchMedia(media),\r\n            listeners   = [],\r\n            index       = 0;\r\n\r\n        mql.addListener = function(listener) {\r\n            // Changes would not occur to css media type so return now (Affects IE <= 8)\r\n            if (!hasMediaQueries) {\r\n                return;\r\n            }\r\n\r\n            // Set up 'resize' listener for browsers that support CSS3 media queries (Not for IE <= 8)\r\n            // There should only ever be 1 resize listener running for performance\r\n            if (!isListening) {\r\n                isListening = true;\r\n                window.addEventListener('resize', handleChange, true);\r\n            }\r\n\r\n            // Push object only if it has not been pushed already\r\n            if (index === 0) {\r\n                index = queries.push({\r\n                    mql         : mql,\r\n                    listeners   : listeners\r\n                });\r\n            }\r\n\r\n            listeners.push(listener);\r\n        };\r\n\r\n        mql.removeListener = function(listener) {\r\n            for (var i = 0, il = listeners.length; i < il; i++){\r\n                if (listeners[i] === listener){\r\n                    listeners.splice(i, 1);\r\n                }\r\n            }\r\n        };\r\n\r\n        return mql;\r\n    };\r\n}());\r\n\n\r/*\n\tBy Osvaldas Valutis, www.osvaldas.info\n\tAvailable for use under the MIT License\n*/\n\n;(function( $, window, document, undefined )\n{\n\t$.fn.doubleTapToGo = function( params )\n\t{\n\t\tif( !( 'ontouchstart' in window ) &&\n\t\t\t!navigator.msMaxTouchPoints &&\n\t\t\t!navigator.userAgent.toLowerCase().match( /windows phone os 7/i ) ) return false;\n\n\t\tthis.each( function()\n\t\t{\n\t\t\tvar curItem = false;\n\n\t\t\t$( this ).on( 'click', function( e )\n\t\t\t{\n\t\t\t\tvar item = $( this );\n\t\t\t\tif( item[ 0 ] != curItem[ 0 ] )\n\t\t\t\t{\n\t\t\t\t\te.preventDefault();\n\t\t\t\t\tcurItem = item;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t$( document ).on( 'click touchstart MSPointerDown', function( e )\n\t\t\t{\n\t\t\t\tvar resetItem = true,\n\t\t\t\t\tparents\t  = $( e.target ).parents();\n\n\t\t\t\tfor( var i = 0; i < parents.length; i++ )\n\t\t\t\t\tif( parents[ i ] == curItem[ 0 ] )\n\t\t\t\t\t\tresetItem = false;\n\n\t\t\t\tif( resetItem )\n\t\t\t\t\tcurItem = false;\n\t\t\t});\n\t\t});\n\t\treturn this;\n\t};\n})( jQuery, window, document );\n"],"file":"plugins.js","sourceRoot":"/source/"}