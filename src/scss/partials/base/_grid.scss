.container {
	@include container;

	// 1: Prevent horizontal scrollbar.
	&.-width-full {
		overflow-x: hidden; // 1

		&.-layout-fixed,
		&.-layout-fixed & { width: 100%; }
	}
}

// 1: .container not filling full width allows
// for negative margin.
.row,
[class*='block-row-'] {
	@include clearfix;
	margin: 0 (- grid(gutter)/2); // 1

	// No margin required.
	&.-gutter-none { margin: 0; }
}

// Block-row
[class*='block-row-'] {
	display: block;
	list-style: none;
	padding: 0;
}

// Columns
// 1: Use transparent borders for padding.
// 2: Clip to allow setting a background color without filling the whole area.
[class*='col-'],
[class*='block-row-'] > * {
	background-clip: padding-box; // 2
	border-left: (grid(gutter)/2) solid transparent; // 1
	border-right: (grid(gutter)/2) solid transparent; // 1
	display: block;
	float: left;
	min-height: 1px;
	width: 100%;

	[dir='rtl'] & { float: right; }
}

// Movable columns
[class*='col-'] {
	&[class*='u-offset'],
	&[class*='u-push'],
	&[class*='u-pull'] { position: relative; }
}

// 1: Remove gutter
[class*='block-row-'].-gutter-none > *,
.row.-gutter-none > [class*=col-] {
	background-clip: border-box; // 1
	border: 0; // 1
}

// Equal height
// Stop rows collapsing
.row {
	&.-height-equal {
		display: table;
		height: 1px;
		table-layout: fixed; // 1
		width: calc(100% + #{grid(gutter)});

		&.-gutter-none { width: 100%; }

		// Without this columns shift right.
		&:before { display: none !important; } // 1

		> [class*='col-'] {
			float: none;
			vertical-align: top;
		}
	}
}

// XXS, XS, S, M, L grids
@each $bp in map-keys(grid(breakpoints)) {
	@if $bp == xxs {
		@include grid-columns($bp);
		@include block-grid-columns($bp);
	} @else {
		@media #{bp-min($bp)} {
			@include grid-columns($bp);
			@include block-grid-columns($bp);
		}
	}
}
