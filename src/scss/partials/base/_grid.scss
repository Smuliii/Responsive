.container,
.container-full { @include container; }

// 1: Prevent horizontal scrollbar.
.container-full {
	overflow-x: hidden; // 1

	&.fixed,
	.fixed & { width: 100%; }
}

// 1: .container not filling full width allows
// for negative margin.
.row,
[class*='block-row-'] {
	@include clearfix;
	margin: 0 (- grid(gutter)/2); // 1
}

// No margin required.
.no-gutter { margin: 0; }

// Block-row
[class*='block-row-'] {
	display: block;
	list-style: none;
	padding: 0;
}

// Columns
// 1: Use transparent borders for padding.
// 2: Clip to allow setting a background color without filling the whole area.
[class*=col-],
[class*='block-row-'] > * {
	background-clip: padding-box; // 2
	border-left: (grid(gutter)/2) solid transparent; // 1
	border-right: (grid(gutter)/2) solid transparent; // 1
	display: block;
	float: left;
	min-height: 1px;
	width: 100%;

	[dir='rtl'] & { float: right; }
}

// Movable columns
[class*=col-] {
	&[class*=offset],
	&[class*=push],
	&[class*=pull] { position: relative; }
}

// 1: Remove gutter
[class*='block-row-'].no-gutter > *,
.no-gutter > [class*=col-] {
	background-clip: border-box; // 1
	border: 0; // 1
}

// Equal height
// Stop rows collapsing
.equal-height {
	display: table;
	height: 1px;
	table-layout: fixed; // 1
	width: calc(100% + #{grid(gutter)});

	&.no-gutter { width: 100%; }

	// Without this columns shift right.
	&:before { display: none !important; } // 1

	> [class*=col-] {
		float: none;
		vertical-align: top;
	}
}

// XXS, XS, S, M, L grids
@each $bp in map-keys(grid(breakpoints)) {
	@if $bp == xxs {
		@include grid-columns($bp);
		@include block-grid-columns($bp);
	} @else {
		@media #{bp-min($bp)} {
			@include grid-columns($bp);
			@include block-grid-columns($bp);
		}
	}
}
